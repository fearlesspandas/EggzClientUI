
use gdnative::prelude::*;
use gdnative::api::*;
use crate::traits::{CreateSignal,Instanced,InstancedDefault,Defaulted};
use crate::field::{OpType};
use tokio::sync::mpsc;

trait ToMesh{
    fn to_mesh(&self,radius:f32) -> Ref<MeshInstance>;
}
impl ToMesh for OpType{
    fn to_mesh(&self,radius:f32) -> Ref<MeshInstance> {
        match self{
            OpType::empty => {
                let mesh = MeshInstance::new().into_shared();
                let mesh_obj = unsafe{mesh.assume_safe()};
                let box_mesh = CubeMesh::new().into_shared();
                let box_mesh = unsafe{box_mesh.assume_safe()};
                box_mesh.set_size(Vector3{x:25.0,y:radius,z:radius});
                let box_material = SpatialMaterial::new();
                box_material.set_albedo(Color{r:0.0,g:30.0,b:30.0,a:1.0});
                box_mesh.set_material(box_material);
                mesh_obj.set_mesh(box_mesh);
                mesh
            }
            OpType::smack => {
                let mesh = MeshInstance::new().into_shared();
                let mesh_obj = unsafe{mesh.assume_safe()};
                let sphere_mesh = SphereMesh::new().into_shared();
                let sphere_mesh = unsafe{sphere_mesh.assume_safe()};
                sphere_mesh.set_radius(radius.into());
                sphere_mesh.set_height(radius.into());
                let box_material = SpatialMaterial::new();
                box_material.set_albedo(Color{r:100.0,g:100.0,b:0.0,a:1.0});
                sphere_mesh.set_material(box_material);
                mesh_obj.set_mesh(sphere_mesh);
                mesh
            }
            OpType::globular_teleport => {
                let mesh_anchor = MeshInstance::new().into_shared();
                let mesh_0 = MeshInstance::new().into_shared();
                let mesh_1 = MeshInstance::new().into_shared();
                let mesh_2 = MeshInstance::new().into_shared();
                let mesh_3 = MeshInstance::new().into_shared();
                let mesh_obj_anchor = unsafe{mesh_anchor.assume_safe()};
                let mesh_obj_0 = unsafe{mesh_0.assume_safe()};
                let mesh_obj_1 = unsafe{mesh_1.assume_safe()};
                let mesh_obj_2 = unsafe{mesh_2.assume_safe()};
                let mesh_obj_3 = unsafe{mesh_3.assume_safe()};
                let sphere_mesh = SphereMesh::new().into_shared();
                let sphere_mesh = unsafe{sphere_mesh.assume_safe()};
                sphere_mesh.set_radius(radius.into());
                sphere_mesh.set_height(radius.into());
                let box_material = SpatialMaterial::new();
                box_material.set_albedo(Color{r:100.0,g:100.0,b:0.0,a:1.0});
                sphere_mesh.set_material(box_material);
                mesh_obj_anchor.set_mesh(sphere_mesh);
                mesh_obj_0.set_mesh(sphere_mesh);
                mesh_obj_1.set_mesh(sphere_mesh);
                mesh_obj_2.set_mesh(sphere_mesh);
                mesh_obj_3.set_mesh(sphere_mesh);
                let mut transform = mesh_anchor.transform();
                transform.origin = Vector3{x:12.5,y:radius/2.0,z:radius};
                mesh_obj_0.set_transform(transform);
                transform.origin = Vector3{x:7.0,y:radius,z:radius/2.0};
                mesh_obj_1.set_transform(transform);
                transform.origin = Vector3{x:0.0,y:0.0,z:0.0};
                mesh_obj_2.set_transform(transform);
                transform.origin = Vector3{x:0.0,y:0.0,z:0.0};
                mesh_obj_3.set_transform(transform);
                
                mesh_obj_anchor.add_child(mesh_obj_0,true);
                mesh_obj_anchor.add_child(mesh_obj_1,true);
                mesh_obj_anchor.add_child(mesh_obj_2,true);
                mesh_obj_anchor.add_child(mesh_obj_3,true);
                mesh_anchor
            }
            
        }
    }
}
#[derive(NativeClass)]
#[inherit(Spatial)]
pub struct FieldAbilityMesh{
    mesh:Ref<MeshInstance>,
}
impl InstancedDefault<Spatial,OpType> for FieldAbilityMesh{
    fn make(args:&OpType) -> Self{
        FieldAbilityMesh{
            mesh:args.to_mesh(5.0),
        }
    }
}
#[methods]
impl FieldAbilityMesh{
    #[method]
    fn _ready(&self,#[base] owner:TRef<Spatial>){
        let mesh = unsafe{self.mesh.assume_safe()};
        owner.add_child(mesh,true);
    }
}
